# 1. 原型与原型链
## 1). 所有构造函数都有一个特别的属性:
    `prototype` : 显式原型属性
## 2). 所有实例对象都有一个特别的属性:
    `__proto__` : 隐式原型属性
## 3). 显式原型与隐式原型的关系
    函数的prototype: 定义函数时被自动赋值,即为原型对象
    实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值
    原型对象即为当前实例对象的父对象
    原型对象：它不是一个空的Object对象，但是它的__proto__永远指向Object的prototype
## 4). 原型链
    所有的实例对象都有__proto__属性, 它指向的就是原型对象
    这样通过__proto__属性就形成了一个链的结构---->隐式原型链
    当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找
    当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作
## 5). 详图
    function Foo () {}
    var f1 = new Foo()
    var f2 = new Foo()
    var o1 = {}
    var o2 = {}
![](https://i.imgur.com/Q3nxgq6.png)
## 6）instanceof是如何进行判断的？
	表达式 A instanceof B
	如果函数B的显示原型对象在实例对象A的隐式原型链上，返回true，否则返回false
## 7)特殊
	Function函数是通过new自己产生的实例
	Object函数是通过newFunction产生的实例
	所有的函数都是new Function产生的，所以所有函数的隐式原型都是相等的，都等于Function的显示原型。
	原型链的头就是Object函数的原型对象，它的隐式原型为null
# 2. 执行上下文与执行上下文栈
## 1). 变量提升与函数提升
    变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)
    函数提升: 在函数定义语句之前, 就执行该函数
    先有函数提升, 再有变量提升
### 1.1）变量提升和函数提升是如何产生的？
	JS引擎预处理产生
## 2). 理解
	首先js代码是分为全局代码和函数代码
	执行上下文分为全局执行上下文和函数执行上下文
    执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性
    执行上下文栈: 栈的特点:后进先出
		1、在全局代码执行前，js引擎就会创建一个栈来存储管理所有的执行上下文对象
		2、在全局执行上下文（window）确定后，将其添加到栈中进行压栈操作
		3、在函数执行上下文创建后将其添加在栈中，压栈
		4、在当前函数执行完后，将栈顶的对象移出（出栈）
		5、当所有代码执行完后，栈中只剩下window
## 3). 分类:
    全局执行上下文是真实存在的对象: window
	1、在执行全局代码前将window确定为全局执行上下文
	2、对全局数据进行预处理：
		var 定义的全局变量先提升，赋值为undefined 添加为window的属性
		function声明的全局函数，赋值为function函数  添加为window的方法
		this赋值为window
		开始执行全局代码（从window对象中查找对应的属性变量）
    函数执行上下文不是真实存在的对象: 对程序员来说是透明的
	1、在调用函数，准备执行函数体之前，创建对应的函数执行上下文
	2、对局部数据进行预处理：
		形参变量赋值为实参  添加为函数执行上下文对象的属性
		arguments赋值为实参列表，添加为函数执行上下文的属性
		var 定义的局部变量先局部提升，赋值为undefined 添加为函数执行上下文的属性
		function声明的局部函数，赋值为function函数  添加为函数执行上下文的方法
		this赋值为调用函数的对象
		开始执行函数体代码

## 4). 生命周期
    全局执行上下文 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
    函数执行上下文 : 调用函数时产生,调用几次产生几个，函数执行完时死亡，总共有n+1个执行上下文  1个全局执行上下文+n个函数执行上下文
## 5). 包含哪些属性:
    全局 : 
        用var定义的全局变量  ==>undefined
        使用function声明的函数   ===>function
        this   ===>window
    函数
        用var定义的局部变量  ==>undefined
        使用function声明的函数   ===>function
        this   ===> 调用函数的对象, 如果没有指定就是window 
        形参变量   ===>对应实参值
        arguments ===>实参列表的伪数组
## 6). 执行上下文创建和初始化的过程
    全局:
        在全局代码执行前最先创建一个全局执行上下文(window)
        收集一些全局变量, 并初始化
        将这些变量设置为window的属性
    函数:
        在调用函数时, 在执行函数体之前先创建一个函数执行上下文
        收集一些局部变量, 并初始化
        将这些变量设置为执行上下文的属性

# 3. 作用域与作用域链
## 1). 理解:
    作用域: 一块代码区域, 在编码时就确定了, 不会再变化, 隔离变量/隐藏实现
    作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量
## 2). 分类:
    全局
    函数
    js没有块作用域(在ES6之前)
## 3). 作用
    作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突
    作用域链: 查找变量
## 4). 区别作用域与执行上下文
    作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了
    执行上下文: 动态的, 函数调用时动态创建, 当执行结束消失
    联系: 执行上下文环境是在对应的作用域中的
## 5)作用域与执行上下文联系
	上下文环境是属于所在作用域的，全局上下文===>全局作用域,函数上下文===>函数作用域
# 4. 闭包 
## 1). 理解:
    当嵌套的内部函数引用了外部函数的变量，且外部函数被调用时就产生了闭包
	牛逼一点的解释是：当函数可以记住并且可以访问自己所处的词法作用域时就会产生闭包
    通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性
## 2). 作用:
    延长局部变量的生命周期
    让函数外部能间接操作内部的局部变量
## 3). 写一个闭包程序
    function fn1() {
      var a = 2;
      function fn2() {
        a++;
        console.log(a);
      }
      return fn2;
    }
    var f = fn1();
    f();
    f();
## 4). 闭包应用:
    循环遍历加监听: 给多个li加点击监听, 读取当前下标
    模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为
    JS框架(jQuery)大量使用了闭包

## 5). 缺点:
    变量占用内存的时间可能会过长
    可能导致内存泄露
    解决: 及时释放 : f = null; //让内部函数对象成为垃圾对象
    
# 5. 内存溢出与内存泄露
## 1). 内存溢出
    一种程序运行出现的错误
    当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误
## 2). 内存泄露
    占用的内存没有及时释放
    内存泄露积累多了就容易导致内存溢出
    常见的内存泄露:
        意外的全局变量
        没有及时清理的计时器或回调函数
        闭包