#### 左查询
##### 左查询是对等号左边的变量进行查询,例如：
```
var a=3;
```
##### 以上声明变量并且赋值的时候需要进行一次左查询，要想给a赋值为3，首先要找到a，a在等号的左边，因此进行一次左查询。
#### 左查询的特点是：在整个作用域中没有找到变量的声明，那么会在全局作用域中主动进行一次声明。
#### 右查询
##### 对于等号的非左边的变量进行查询，例如：
```
console.log(a);
```
#### 右查询的特点是：在整个作用域中没有找到变量的声明，就会直接报ReferenceError编译的错误。
```
		(function(){
			function test(a){
				b = a;
				console.log(b);
			}
			test(2);
		})();
		console.log(b);
		console.log(a);
输出结果为：
2
2
Uncaught ReferenceError: a is not defined
```
##### 以上代码的执行结果为什么是这样呢？下面我们来解释一下：
##### 首先test函数是声明并且调用在一个自执行函数中，自执行函数又叫(IIFE)，在自执行函数中，执行到test(2)调用函数时，开始执行test函数的内容，首先给传入实参2赋值给变量a，在自行b=a时对b进行的一次左查询，要把a的值赋值给b，左查询会在整个作用域中寻找变量b的声明，显然没有找到，那么在全局作用域中会主动给b进行一次声明，然后a的值赋值给b，那么现在在test函数中输出的b的值为2；在全局中输出b的值对b进行一次右查询，因为在执行test函数的时候已经在全局作用域中声明过b了，并且给他赋值为2，所以此时全局中的b的值也为2，全局中输出a，进行的是对a一次右查询，作用域中没有a的声明，因此报错。
```
var a=8;
   (function(){
	   function test(){
			console.log(a);
		}
		test();
	})();
	输出结果:8
		
```
##### 以上代码调用函数时对a进行的是右查询，会在整个作用域中找a的声明，在全局中找到了并且已经赋值为8，所以输出a为8.
